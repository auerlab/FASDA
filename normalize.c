/***************************************************************************
 *  Description:
 *      Compute normalized abundances from raw counts provided in a TSV file
 *      similar to Kallisto abundances.tsv.  The TSV can be generated by
 *      the abundance subcommand from alignment data if necessary.
 *
 *  Raw yeast data with 48 biological replicates:
 *      https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4878611/
 *      https://www.ebi.ac.uk/ena/browser/view/PRJEB5348 (FASTQ files)
 *      https://figshare.com/ndownloader/files/2194841 (sample map)
 *
 *  Arguments:

 *  Returns:
 *
 *  History: 
 *  Date        Name        Modification
 *  2022-05-04  Jason Bacon Begin
 ***************************************************************************/

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sysexits.h>
#include <stdlib.h>
#include <math.h>
#include <xtend/dsv.h>
#include <xtend/file.h>
#include <xtend/mem.h>
#include <xtend/math.h> // double_cmp()
#include "normalize.h"

int     main(int argc,char *argv[])

{
    int     arg;
    
    if ( argc < 3 )
	usage(argv);

    for (arg = 1; *argv[arg] == '-'; ++arg)
    {
	if ( strcmp(argv[arg], "--mrn") == 0 )
	    ;
	else
	    usage(argv);
    }
    
    return mrn(argc, argv, arg);
}


/***************************************************************************
 *  Use auto-c2man to generate a man page from this comment
 *
 *  Library:
 *      #include <>
 *      -l
 *
 *  Description:
 *  
 *  Arguments:
 *
 *  Returns:
 *
 *  Examples:
 *
 *  Files:
 *
 *  Environment
 *
 *  See also:
 *
 *  History: 
 *  Date        Name        Modification
 *  2022-05-14  Jason Bacon Begin
 ***************************************************************************/

int     mrn(int argc, char *argv[], int arg)

{
    dsv_line_t  dsv_line[DIFFANAL_MAX_SAMPLES];
    int         sample, sample_count;
    FILE        *abundance_streams[DIFFANAL_MAX_SAMPLES],
		*tmp_streams[DIFFANAL_MAX_SAMPLES];
    char        **abundance_files = &argv[arg], *end, *target_id, *count_str;
    size_t      feature_count = 0, c;
    double      count, sum_lcs, lc[DIFFANAL_MAX_SAMPLES],
		pseudo_ref, *ratios, median_ratio[DIFFANAL_MAX_SAMPLES];
    
    for (sample_count = 0; arg < argc; ++sample_count, ++arg)
    {
	if ( (abundance_streams[sample_count] =
		xt_fopen(abundance_files[sample_count], "r")) == NULL )
	{
	    fprintf(stderr, "normalize: Could not open %s for read: %s.\n",
		    abundance_files[sample_count], strerror(errno));
	    return EX_NOINPUT;
	}
	
	if ( (tmp_streams[sample_count] = tmpfile()) == NULL )
	{
	    fprintf(stderr, "normalize: Could not open temp file: %s\n",
		    strerror(errno));
	    return EX_NOINPUT;
	}
	dsv_line_init(&dsv_line[sample_count]);
    }
    
    skip_headers(abundance_files, abundance_streams, dsv_line, sample_count);

    // Abundance file format:
    // target_id       length  eff_length      est_counts      tpm
    
    while ( ! feof(abundance_streams[0]) )
    {
	for (sample = 0, sum_lcs = 0; sample < sample_count; ++sample)
	{
	    if ( dsv_line_read(&dsv_line[sample], abundance_streams[sample],
				"\t") == EOF )
	    {
		check_all_eof(abundance_files, abundance_streams, sample, sample_count);
		break;
	    }
	    else
	    {
		target_id = DSV_LINE_FIELDS_AE(&dsv_line[sample], 0);
		count_str = DSV_LINE_FIELDS_AE(&dsv_line[sample], 3);
		
		// Dummy output: Just echo non-normalized counts to test UI
		printf("%s\t%s\n", target_id, count_str);
		
		if ( (sample > 0) && (strcmp(target_id,
			DSV_LINE_FIELDS_AE(&dsv_line[sample - 1], 0)) != 0) )
		{
		    fprintf(stderr,
			    "normalize: %s, %s: Different feature IDs on line %zu\n.\n",
			    abundance_files[sample - 1],
			    abundance_files[sample], feature_count + 1);
		    // FIXME: Close all files
		    return EX_DATAERR;
		}

		/*
		 *  Median of ratios normalization
		 *  https://scienceparkstudygroup.github.io/research-data-management-lesson/median_of_ratios_manual_normalization/index.html
		 *  Similar to TMM but more robust: doi 10.1093/bib/bbx008
		 *
		 *  First pass:
		 *
		 *  Read raw counts for all genes and all samples
		 *
		 *  1.  Take log of every count (just for filtering in step 3?)
		 *  2.  Average of all samples for the gene
		 *      (compute pseudo-reference)
		 */
		
		count = strtof(DSV_LINE_FIELDS_AE(&dsv_line[sample], 3), &end);
		if ( *end != '\0' )
		{
		    fprintf(stderr, "normalize: Invalid count: %s\n",
			    DSV_LINE_FIELDS_AE(&dsv_line[sample_count],0));
		    return EX_DATAERR;
		}
		lc[sample] = log(count);
		sum_lcs += lc[sample];
	    }
	}

	/*
	 *  3.  Remove genes with -inf as average
	 *  4.  Subtract pseudo-reference from each log(expression)
	 *      This is actually a ratio since subtracting from log(v)
	 *      is dividing v. We'll need to store this value and later
	 *      sort to find median.
	 */   
	
	if ( ! feof(abundance_streams[0]) )
	{
	    pseudo_ref = sum_lcs / sample_count;
	    printf("pseudo_ref = %f\n", pseudo_ref);
	    if ( pseudo_ref != -INFINITY )
		for (sample = 0, sum_lcs = 0; sample < sample_count; ++sample)
		    fprintf(tmp_streams[sample], "%f\n",
			    lc[sample] - pseudo_ref);
	    ++feature_count;
	}
    }
    
    /*
     *  Second pass:
     *
     *  5.  Take the median of the ratios for each sample
     *  6.  exp(median) = count scaling factor
     */

    for (sample = 0; sample < sample_count; ++sample)
    {
	rewind(abundance_streams[sample]);
	rewind(tmp_streams[sample]);
	
	ratios = xt_malloc(feature_count, sizeof(*ratios));
	if ( ratios == NULL )
	{
	    fprintf(stderr, "normalize: Could not allocate ratios[%zu]\n",
		    feature_count);
	    return EX_UNAVAILABLE;
	}
	for (c = 0; c < feature_count; ++c)
	    fscanf(tmp_streams[sample], "%lf", &ratios[c]);
	qsort(ratios, feature_count, sizeof(*ratios),
	      (int (*)(const void *,const void *))double_cmp);
	printf("Sorted %zu:\n", feature_count);
	for (c = 0; c < feature_count; ++c)
	{
	    if ( c % 1000 == 0 )
		printf("%f\n", ratios[c]);
	}
	if ( feature_count % 2 == 1 )
	    median_ratio[sample] = ratios[feature_count / 2];
	else
	    median_ratio[sample] = (ratios[feature_count / 2] +
			    ratios[feature_count / 2 + 1]) / 2;
	printf("median ratio = %f\n", median_ratio[sample]);
    }
    
    /*
     *  Third pass:
     *
     *  7.  Divide counts by scaling factor
     */
    
    skip_headers(abundance_files, abundance_streams, dsv_line, sample_count);
    feature_count = 0;
    while ( ! feof(abundance_streams[0]) )
    {
	for (sample = 0, sum_lcs = 0; sample < sample_count; ++sample)
	{
	    if ( dsv_line_read(&dsv_line[sample], abundance_streams[sample],
				"\t") == EOF )
	    {
		check_all_eof(abundance_files, abundance_streams, sample, sample_count);
		break;
	    }
	    else
	    {
		if ( pseudo_ref == -INFINITY )
		{
		    fprintf(stderr, "Discarding ratios[%zu]\n",
			    feature_count);
		}
		else
		{
		    // ratios[sample][feature_count] =
		    //      log(count) - ratios[feature_count];
		}
	    }
	}
	++feature_count;
    }
    
    // Sort ratios and find exp(median) = scaling factor
    // for (sample = 0; sample < sample_count; ++sample)
    // {
    //     qsort(ratios[sample], feature_count, sizeof(*ratios[sample][0]),
    //      compar);
    //     if ( feature_count % 2 == 1 )
    //         scaling_factor = exp(ratios[sample][middle]);
    //     else
    //         scaling_factor = exp((ratios[sample][middle] +
    //                               ratios[sample][middle + 1]) / 2);
    // }
    
    for (sample = 0; sample < sample_count; ++sample)
	fclose(abundance_streams[sample]);
    
    return EX_OK;
}


/***************************************************************************
 *  Use auto-c2man to generate a man page from this comment
 *
 *  Library:
 *      #include <>
 *      -l
 *
 *  Description:
 *  
 *  Arguments:
 *
 *  Returns:
 *
 *  Examples:
 *
 *  Files:
 *
 *  Environment
 *
 *  See also:
 *
 *  History: 
 *  Date        Name        Modification
 *  2022-05-14  Jason Bacon Begin
 ***************************************************************************/

void    skip_headers(char *abundance_files[], FILE *abundance_streams[],
		     dsv_line_t dsv_line[], size_t sample_count)

{
    size_t  c;
    
    for (c = 0; c < sample_count; ++c)
    {
	// Every abundance file should have a 1-line header
	dsv_line_read(&dsv_line[c], abundance_streams[c], "\t");
	//puts(DSV_LINE_FIELDS_AE(&dsv_line[sample_count], 0));
	if ( strcmp(DSV_LINE_FIELDS_AE(&dsv_line[c], 0), "target_id") != 0 )
	{
	    fprintf(stderr, "normalize: %s: Expected header starting with \"target_id\".\n",
		    abundance_files[c]);
	    fprintf(stderr, "Got %s\n", DSV_LINE_FIELDS_AE(&dsv_line[c], 0));
	    exit(EX_DATAERR);
	}
    }
}


/***************************************************************************
 *  Use auto-c2man to generate a man page from this comment
 *
 *  Library:
 *      #include <>
 *      -l
 *
 *  Description:
 *  
 *  Arguments:
 *
 *  Returns:
 *
 *  Examples:
 *
 *  Files:
 *
 *  Environment
 *
 *  See also:
 *
 *  History: 
 *  Date        Name        Modification
 *  2022-05-14  Jason Bacon Begin
 ***************************************************************************/

void    check_all_eof(char *abundance_files[], FILE *abundance_streams[],
	      size_t sample, size_t sample_count)

{
    size_t  c;
    
    // Make sure all files reach EOF together
    for (c = 0; c < sample_count; ++c)
	if ( getc(abundance_streams[c]) != EOF )
	{
	    fprintf(stderr, "normalize: EOF reached on %s but not %s\n",
		    abundance_files[sample], abundance_files[c]);
	    exit(EX_DATAERR);
	}
}


void    usage(char *argv[])

{
    fprintf(stderr, "Usage: %s abundance1.tsv abundance2.tsv ...\n", argv[0]);
    exit(EX_USAGE);
}
